import os
from dotenv import load_dotenv
load_dotenv()  # Ÿäÿ≥ÿ™ÿÆÿØŸÖ ŸÖÿ≠ŸÑŸäŸãÿß ŸÅŸÇÿ∑ ‚Äî Render ÿ≥Ÿäÿ™ÿ¨ÿßŸáŸÑŸá

BOT_TOKEN = os.getenv('BOT_TOKEN')
API_KEY = os.getenv('API_KEY')
API_SECRET = os.getenv('API_SECRET')
ADMIN_USER_ID = os.getenv('ADMIN_USER_ID')
if ADMIN_USER_ID:
    ADMIN_USER_ID = int(ADMIN_USER_ID)

import os
import logging
import requests
import hashlib
import hmac
import time
import sqlite3
import re
import threading
import queue
import csv
from datetime import datetime, timedelta
import tempfile
import pytz
from urllib.parse import urlencode
from dotenv import load_dotenv

# ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ŸÖŸÜ ŸÖŸÑŸÅ .env
load_dotenv()

# ÿ•ÿπÿØÿßÿØ ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("bot_errors.log", encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# ÿ™ŸáŸäÿ¶ÿ© ÿßŸÑÿ®Ÿàÿ™





# ÿ™ŸáŸäÿ¶ÿ© telebot
bot = None
try:
    if BOT_TOKEN and BOT_TOKEN != 'ÿ™ŸàŸÉŸÜ_ÿßŸÑÿ®Ÿàÿ™_ÿßŸÑÿÆÿßÿµ_ÿ®ŸÉ':
        import telebot
        from telebot.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton
        bot = telebot.TeleBot(BOT_TOKEN)
        logger.info("‚úÖ ÿ™ŸÖ ÿ™ŸáŸäÿ¶ÿ© ÿ®Ÿàÿ™ Telegram ÿ®ŸÜÿ¨ÿßÿ≠")
    else:
        logger.warning("‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ BOT_TOKENÿå ÿßŸÑÿ®Ÿàÿ™ ŸäÿπŸÖŸÑ ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±")
        class MockBot:
            def __init__(self):
                self.message_handlers = []
            def message_handler(self, **kwargs):
                def decorator(func):
                    self.message_handlers.append((func, kwargs))
                    return func
                return decorator
            def callback_query_handler(self, **kwargs):
                def decorator(func):
                    return func
                return decorator
            def send_message(self, chat_id, text, **kwargs):
                print(f"üì® [TEST] ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ÿ•ŸÑŸâ {chat_id}: {text}")
            def edit_message_text(self, text, chat_id, message_id, **kwargs):
                print(f"‚úèÔ∏è [TEST] ÿ™ÿπÿØŸäŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© {message_id}: {text}")
            def delete_message(self, chat_id, message_id):
                print(f"üóëÔ∏è [TEST] ÿ≠ÿ∞ŸÅ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© {message_id}")
            def answer_callback_query(self, callback_query_id, **kwargs):
                print(f"üîî [TEST] ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑÿßÿ≥ÿ™ÿπŸÑÿßŸÖ {callback_query_id}")
            def register_next_step_handler(self, message, func, *args, **kwargs):
                print(f"‚è≠Ô∏è [TEST] ÿ™ÿ≥ÿ¨ŸäŸÑ ŸÖÿπÿßŸÑÿ¨ ÿßŸÑÿÆÿ∑Ÿàÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©")
            def send_document(self, chat_id, document, **kwargs):
                print(f"üìé [TEST] ÿ•ÿ±ÿ≥ÿßŸÑ ŸÖÿ≥ÿ™ŸÜÿØ ÿ•ŸÑŸâ {chat_id}")
            def polling(self, none_stop=True, timeout=120):
                print("ü§ñ [TEST] ÿ®ÿØÿ° Ÿàÿ∂ÿπ ÿßŸÑÿßÿ≥ÿ™ÿ∑ŸÑÿßÿπ (ŸàŸáŸÖŸä)")
                while True:
                    time.sleep(10)
                    
        class MockReplyKeyboardMarkup:
            def __init__(self, resize_keyboard=True):
                self.resize_keyboard = resize_keyboard
            def row(self, *buttons):
                return self
        class MockKeyboardButton:
            def __init__(self, text):
                self.text = text
        class MockInlineKeyboardMarkup:
            def __init__(self):
                pass
            def row(self, *buttons):
                return self
        class MockInlineKeyboardButton:
            def __init__(self, text, callback_data=None):
                self.text = text
                self.callback_data = callback_data
        
        ReplyKeyboardMarkup = MockReplyKeyboardMarkup
        KeyboardButton = MockKeyboardButton
        InlineKeyboardMarkup = MockInlineKeyboardMarkup
        InlineKeyboardButton = MockInlineKeyboardButton
        bot = MockBot()
        
except ImportError:
    logger.error("‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ÿ´ÿ®Ÿäÿ™ telebot. ŸÇŸÖ ÿ®ÿ™ÿ´ÿ®Ÿäÿ™Ÿá: pip install pyTelegramBotAPI")
    class MockBot:
        def __init__(self):
            self.message_handlers = []
        def __getattr__(self, name):
            def mock_method(*args, **kwargs):
                print(f"ü§ñ [MOCK] {name}{args} {kwargs}")
            return mock_method
    class MockReplyKeyboardMarkup:
        def __init__(self, resize_keyboard=True):
            self.resize_keyboard = resize_keyboard
        def row(self, *buttons):
            return self
    class MockKeyboardButton:
        def __init__(self, text):
            self.text = text
    ReplyKeyboardMarkup = MockReplyKeyboardMarkup
    KeyboardButton = MockKeyboardButton
    InlineKeyboardMarkup = MockReplyKeyboardMarkup
    InlineKeyboardButton = MockKeyboardButton
    bot = MockBot()
except Exception as e:
    logger.error(f"‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ŸáŸäÿ¶ÿ© ÿßŸÑÿ®Ÿàÿ™: {e}")
    class MockBot:
        def __init__(self):
            self.message_handlers = []
        def __getattr__(self, name):
            def mock_method(*args, **kwargs):
                print(f"ü§ñ [MOCK] {name}{args} {kwargs}")
            return mock_method
    class MockReplyKeyboardMarkup:
        def __init__(self, resize_keyboard=True):
            self.resize_keyboard = resize_keyboard
        def row(self, *buttons):
            return self
    class MockKeyboardButton:
        def __init__(self, text):
            self.text = text
    ReplyKeyboardMarkup = MockReplyKeyboardMarkup
    KeyboardButton = MockKeyboardButton
    InlineKeyboardMarkup = MockReplyKeyboardMarkup
    InlineKeyboardButton = MockKeyboardButton
    bot = MockBot()

# ŸÜÿ∏ÿßŸÖ ÿ∞ŸÉŸä ŸÑÿ•ÿØÿßÿ±ÿ© ÿ≠ÿØŸàÿØ Binance
class BinanceRateLimiter:
    def __init__(self):
        self.last_request_time = 0
        self.request_count = 0
        self.lock = threading.Lock()
        
    def wait_if_needed(self):
        with self.lock:
            current_time = time.time()
            elapsed = current_time - self.last_request_time
            
            if elapsed > 1.0:
                self.request_count = 0
                self.last_request_time = current_time
                return
            
            if self.request_count >= 2:
                sleep_time = 1.1 - elapsed
                if sleep_time > 0:
                    logger.info(f"‚è∞ Rate limiting: Waiting {sleep_time:.2f}s")
                    time.sleep(sleep_time)
                self.request_count = 0
                self.last_request_time = time.time()
            else:
                self.request_count += 1

binance_limiter = BinanceRateLimiter()

# ŸÜÿ∏ÿßŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿßÿ≥ÿ™ÿ±ÿØÿßÿØÿßÿ™
class RedemptionLogger:
    def __init__(self, db_path="redemptions.db"):
        self.db_path = db_path
        self.init_database()
    
    def _convert_datetime_for_sqlite(self, dt):
        return dt.strftime('%Y-%m-%d %H:%M:%S')
    
    def init_database(self):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS redemptions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                username TEXT,
                code TEXT,
                amount REAL,
                currency TEXT,
                status TEXT,
                timestamp TEXT
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS usage_tracking (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                request_type TEXT,
                timestamp TEXT
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS daily_statistics (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                date TEXT UNIQUE,
                total_redemptions INTEGER DEFAULT 0,
                successful_redemptions INTEGER DEFAULT 0,
                total_amount REAL DEFAULT 0,
                unique_users INTEGER DEFAULT 0
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS settings (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                key TEXT UNIQUE,
                value TEXT
            )
        ''')
        
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_redemptions_user_id ON redemptions(user_id)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_redemptions_timestamp ON redemptions(timestamp)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_usage_user_id ON usage_tracking(user_id)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_usage_timestamp ON usage_tracking(timestamp)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_daily_stats_date ON daily_statistics(date)')
        
        default_settings = [
            ('rate_limit_minute', '20'),
            ('rate_limit_hour', '500'),  
            ('rate_limit_day', '2000'),
            ('auto_cleanup_days', '30'),
            ('language', 'ar'),
            ('max_codes_per_message', '30'),
            ('max_retries', '4'),
            ('retry_delay', '3'),
        ]
        
        cursor.executemany('''
            INSERT OR IGNORE INTO settings (key, value) VALUES (?, ?)
        ''', default_settings)
        
        conn.commit()
        conn.close()
    
    def log_redemption(self, user_id, username, code, amount, currency, status):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        timestamp_str = self._convert_datetime_for_sqlite(datetime.now())
        
        try:
            amount_float = float(amount)
        except (ValueError, TypeError):
            amount_float = 0.0
        
        cursor.execute('''
            INSERT INTO redemptions (user_id, username, code, amount, currency, status, timestamp)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        ''', (user_id, username, code, amount_float, currency, status, timestamp_str))
        
        today = datetime.now().strftime('%Y-%m-%d')
        
        cursor.execute('''
            INSERT OR IGNORE INTO daily_statistics (date) VALUES (?)
        ''', (today,))
        
        if status == 'success':
            cursor.execute('''
                UPDATE daily_statistics SET 
                total_redemptions = total_redemptions + 1,
                successful_redemptions = successful_redemptions + 1,
                total_amount = total_amount + ?
                WHERE date = ?
            ''', (amount_float, today))
        else:
            cursor.execute('''
                UPDATE daily_statistics SET 
                total_redemptions = total_redemptions + 1
                WHERE date = ?
            ''', (today,))
        
        cursor.execute('''
            UPDATE daily_statistics 
            SET unique_users = (
                SELECT COUNT(DISTINCT user_id) 
                FROM redemptions 
                WHERE date(timestamp) = date('now')
            )
            WHERE date = ?
        ''', (today,))
        
        conn.commit()
        conn.close()
    
    def get_user_redemptions(self, user_id, limit=15):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute('''
            SELECT code, amount, currency, status, timestamp 
            FROM redemptions 
            WHERE user_id = ? 
            ORDER BY timestamp DESC
            LIMIT ?
        ''', (user_id, limit))
        results = cursor.fetchall()
        conn.close()
        return results
    
    def get_setting(self, key, default=None):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute('SELECT value FROM settings WHERE key = ?', (key,))
        result = cursor.fetchone()
        conn.close()
        return result[0] if result else default
    
    def set_setting(self, key, value):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute('''
            INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)
        ''', (key, value))
        conn.commit()
        conn.close()
    
    def log_request(self, user_id, request_type):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        timestamp_str = self._convert_datetime_for_sqlite(datetime.now())
        
        cursor.execute('''
            INSERT INTO usage_tracking (user_id, request_type, timestamp)
            VALUES (?, ?, ?)
        ''', (user_id, request_type, timestamp_str))
        conn.commit()
        conn.close()
    
    def get_request_count(self, user_id, time_frame_minutes):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        time_threshold = datetime.now() - timedelta(minutes=time_frame_minutes)
        
        time_threshold_str = self._convert_datetime_for_sqlite(time_threshold)
        
        cursor.execute('''
            SELECT COUNT(*) FROM usage_tracking 
            WHERE user_id = ? AND timestamp >= ?
        ''', (user_id, time_threshold_str))
        result = cursor.fetchone()
        conn.close()
        return result[0] if result else 0
    
    def cleanup_old_data(self):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        auto_cleanup_days = int(self.get_setting('auto_cleanup_days', 30))
        cleanup_date = datetime.now() - timedelta(days=auto_cleanup_days)
        
        cleanup_date_str = self._convert_datetime_for_sqlite(cleanup_date)
        
        cursor.execute('DELETE FROM usage_tracking WHERE timestamp < ?', (cleanup_date_str,))
        cursor.execute('DELETE FROM redemptions WHERE timestamp < ?', (cleanup_date_str,))
        
        conn.commit()
        conn.close()
        logger.info(f"ÿ™ŸÖ ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ£ŸÇÿØŸÖ ŸÖŸÜ {auto_cleanup_days} ŸäŸàŸÖ")
    
    def get_daily_statistics(self, date=None):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        if date is None:
            date = datetime.now().strftime('%Y-%m-%d')
        
        cursor.execute('''
            SELECT total_redemptions, successful_redemptions, total_amount, unique_users
            FROM daily_statistics 
            WHERE date = ?
        ''', (date,))
        
        result = cursor.fetchone()
        conn.close()
        
        if result:
            total_redemptions, successful_redemptions, total_amount, unique_users = result
            success_rate = (successful_redemptions / total_redemptions * 100) if total_redemptions > 0 else 0
            
            return {
                'date': date,
                'total_redemptions': total_redemptions,
                'successful_redemptions': successful_redemptions,
                'total_amount': total_amount,
                'unique_users': unique_users,
                'success_rate': success_rate
            }
        else:
            return {
                'date': date,
                'total_redemptions': 0,
                'successful_redemptions': 0,
                'total_amount': 0,
                'unique_users': 0,
                'success_rate': 0
            }
    
    def get_multiple_days_statistics(self, days=7):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        start_date = (datetime.now() - timedelta(days=days-1)).strftime('%Y-%m-%d')
        
        cursor.execute('''
            SELECT date, total_redemptions, successful_redemptions, total_amount, unique_users
            FROM daily_statistics 
            WHERE date >= ?
            ORDER BY date DESC
        ''', (start_date,))
        
        results = cursor.fetchall()
        conn.close()
        
        stats = []
        for row in results:
            date, total_redemptions, successful_redemptions, total_amount, unique_users = row
            success_rate = (successful_redemptions / total_redemptions * 100) if total_redemptions > 0 else 0
            
            stats.append({
                'date': date,
                'total_redemptions': total_redemptions,
                'successful_redemptions': successful_redemptions,
                'total_amount': total_amount,
                'unique_users': unique_users,
                'success_rate': success_rate
            })
        
        return stats
    
    def export_to_csv(self, user_id=None, days=30):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        start_date = (datetime.now() - timedelta(days=days)).strftime('%Y-%m-%d')
        
        if user_id:
            query = '''
                SELECT user_id, username, code, amount, currency, status, timestamp
                FROM redemptions 
                WHERE timestamp >= ? AND user_id = ?
                ORDER BY timestamp DESC
            '''
            cursor.execute(query, (start_date, user_id))
        else:
            query = '''
                SELECT user_id, username, code, amount, currency, status, timestamp
                FROM redemptions 
                WHERE timestamp >= ?
                ORDER BY timestamp DESC
            '''
            cursor.execute(query, (start_date,))
        
        rows = cursor.fetchall()
        conn.close()
        
        temp_file = tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False, encoding='utf-8')
        
        writer = csv.writer(temp_file)
        writer.writerow(['user_id', 'username', 'code', 'amount', 'currency', 'status', 'timestamp'])
        writer.writerows(rows)
        
        temp_file.close()
        
        return temp_file.name

redemption_logger = RedemptionLogger()

# ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ§ŸÇÿ™ ÿßŸÑŸÖÿ™ŸÇÿØŸÖ
class AdvancedCacheSystem:
    def __init__(self):
        self.cache = {}
        self.lock = threading.Lock()
        self.processed_codes_db = "processed_codes.db"
        self.init_processed_codes_db()
    
    def init_processed_codes_db(self):
        conn = sqlite3.connect(self.processed_codes_db)
        cursor = conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS processed_codes (
                code TEXT PRIMARY KEY,
                status TEXT,
                amount REAL,
                currency TEXT,
                timestamp TEXT
            )
        ''')
        conn.commit()
        conn.close()
    
    def get(self, key):
        with self.lock:
            if key in self.cache and self.cache[key]['expiry'] > time.time():
                return self.cache[key]['value']
            
            conn = sqlite3.connect(self.processed_codes_db)
            cursor = conn.cursor()
            cursor.execute('SELECT status, amount, currency FROM processed_codes WHERE code = ?', (key.replace("code_", ""),))
            result = cursor.fetchone()
            conn.close()
            
            if result:
                status, amount, currency = result
                cached_value = {
                    'status': status,
                    'amount': amount,
                    'currency': currency,
                    'from_db': True
                }
                self.cache[key] = {
                    'value': cached_value,
                    'expiry': time.time() + 3600
                }
                return cached_value
            
            return None
    
    def set(self, key, value, expiry_seconds=300):
        with self.lock:
            self.cache[key] = {
                'value': value,
                'expiry': time.time() + expiry_seconds
            }
            
            code = key.replace("code_", "")
            if 'status' in value and 'amount' in value:
                conn = sqlite3.connect(self.processed_codes_db)
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT OR REPLACE INTO processed_codes (code, status, amount, currency, timestamp)
                    VALUES (?, ?, ?, ?, ?)
                ''', (code, value['status'], value.get('amount', 0), value.get('currency', 'USD'), 
                      datetime.now().strftime('%Y-%m-%d %H:%M:%S')))
                conn.commit()
                conn.close()
    
    def clear_expired(self):
        with self.lock:
            current_time = time.time()
            expired_keys = [k for k, v in self.cache.items() if v['expiry'] <= current_time]
            for key in expired_keys:
                del self.cache[key]

    def cleanup_24h_codes(self):
        try:
            conn = sqlite3.connect(self.processed_codes_db)
            cursor = conn.cursor()
            
            twenty_four_hours_ago = datetime.now() - timedelta(hours=24)
            cleanup_date_str = twenty_four_hours_ago.strftime('%Y-%m-%d %H:%M:%S')
            
            cursor.execute('DELETE FROM processed_codes WHERE timestamp >= ?', (cleanup_date_str,))
            db_deleted = cursor.rowcount
            
            with self.lock:
                keys_to_delete = []
                current_time = time.time()
                
                for key, value in self.cache.items():
                    if 'expiry' in value and value['expiry'] > current_time - 86400:
                        keys_to_delete.append(key)
                
                for key in keys_to_delete:
                    del self.cache[key]
            
            conn.commit()
            conn.close()
            
            logger.info(f"ÿ™ŸÖ ÿ≠ÿ∞ŸÅ {db_deleted} ŸÉŸàÿØ ŸÖŸÜ ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ§ŸÇÿ™ ŸÑÿ¢ÿÆÿ± 24 ÿ≥ÿßÿπÿ©")
            return db_deleted, len(keys_to_delete)
            
        except Exception as e:
            logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿ£ŸÉŸàÿßÿØ ÿßŸÑŸÖÿ§ŸÇÿ™ÿ©: {e}")
            return 0, 0

cache_system = AdvancedCacheSystem()

# ŸÜÿ∏ÿßŸÖ ÿ∑ÿßÿ®Ÿàÿ± ÿßŸÑŸÖŸáÿßŸÖ
task_queue = queue.Queue()
processing = False

def smart_task_processor():
    global processing
    processing = True
    
    while not task_queue.empty():
        try:
            task = task_queue.get_nowait()
            
            if task['type'] == 'multiple_codes':
                time.sleep(1.5)
            
            if task['type'] == 'single_code':
                process_single_code_async(task['message'], task['code'])
            elif task['type'] == 'multiple_codes':
                process_multiple_codes_async(task['message'], task['codes'])
            
            task_queue.task_done()
            time.sleep(0.8)
            
        except queue.Empty:
            break
        except Exception as e:
            logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÖŸáŸÖÿ©: {e}")
            time.sleep(2)
    
    processing = False

def add_to_task_queue(task):
    task_queue.put(task)
    
    if not processing:
        threading.Thread(target=smart_task_processor, daemon=True).start()

def rate_limit_check(user_id):
    minute_limit = int(redemption_logger.get_setting('rate_limit_minute', 20))
    hour_limit = int(redemption_logger.get_setting('rate_limit_hour', 500))
    day_limit = int(redemption_logger.get_setting('rate_limit_day', 2000))
    
    minute_count = redemption_logger.get_request_count(user_id, 1)
    hour_count = redemption_logger.get_request_count(user_id, 60)
    day_count = redemption_logger.get_request_count(user_id, 1440)
    
    if minute_count >= minute_limit:
        return False, "‚ö†Ô∏è ÿ™ÿ¨ÿßŸàÿ≤ÿ™ ÿßŸÑÿ≠ÿØ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ ŸÑŸÑÿ∑ŸÑÿ®ÿßÿ™ ŸÅŸä ÿßŸÑÿØŸÇŸäŸÇÿ©"
    if hour_count >= hour_limit:
        return False, "‚ö†Ô∏è ÿ™ÿ¨ÿßŸàÿ≤ÿ™ ÿßŸÑÿ≠ÿØ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ ŸÑŸÑÿ∑ŸÑÿ®ÿßÿ™ ŸÅŸä ÿßŸÑÿ≥ÿßÿπÿ©"
    if day_count >= day_limit:
        return False, "‚ö†Ô∏è ÿ™ÿ¨ÿßŸàÿ≤ÿ™ ÿßŸÑÿ≠ÿØ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ ŸÑŸÑÿ∑ŸÑÿ®ÿßÿ™ ŸÅŸä ÿßŸÑŸäŸàŸÖ"
    
    return True, ""

def create_binance_signature(api_secret, data):
    if not api_secret:
        logger.error("‚ùå API_SECRET ÿ∫Ÿäÿ± ŸÖÿπŸäŸÜ ÿ£Ÿà ŸÅÿßÿ±ÿ∫")
        return "invalid_signature_empty_api_secret"
    
    try:
        return hmac.new(api_secret.encode('utf-8'), data.encode('utf-8'), hashlib.sha256).hexdigest()
    except AttributeError as e:
        logger.error(f"‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ™ŸàŸÇŸäÿπ: {e}")
        return "invalid_signature_error"

def check_code_in_database(code):
    try:
        conn = sqlite3.connect("redemptions.db")
        cursor = conn.cursor()
        cursor.execute('''
            SELECT status, amount, currency, timestamp 
            FROM redemptions 
            WHERE code = ? 
            ORDER BY timestamp DESC 
            LIMIT 1
        ''', (code,))
        result = cursor.fetchone()
        conn.close()
        
        if result:
            status, amount, currency, timestamp = result
            return {
                'exists': True,
                'status': status,
                'amount': amount,
                'currency': currency,
                'timestamp': timestamp
            }
        return {'exists': False}
    except Exception as e:
        logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸÉŸàÿØ ŸÅŸä ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™: {e}")
        return {'exists': False}

def is_valid_binance_code(code):
    pattern = r'^[A-Z0-9]{16}$'
    if not bool(re.match(pattern, code)):
        return False, "invalid_format"
    
    db_result = check_code_in_database(code)
    if db_result['exists']:
        return True, db_result['status']
    
    cached_result = cache_system.get(f"code_{code}")
    if cached_result:
        return True, cached_result['status']
    
    return True, "not_processed"

def extract_and_filter_codes(text):
    pattern = r'\b[A-Z0-9]{16}\b'
    all_codes = re.findall(pattern, text.upper())
    
    valid_codes = []
    skipped_codes = []
    
    for code in all_codes:
        db_result = check_code_in_database(code)
        if db_result['exists']:
            skipped_codes.append((code, db_result['status']))
            continue
            
        is_valid, status = is_valid_binance_code(code)
        if is_valid and status == "not_processed":
            valid_codes.append(code)
        else:
            skipped_codes.append((code, status))
    
    return valid_codes, skipped_codes

def send_initial_filter_report(message, valid_codes, skipped_codes):
    if not valid_codes and not skipped_codes:
        bot.send_message(message.chat.id,
                        "‚ùå *ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ£ŸÉŸàÿßÿØ ÿµÿßŸÑÿ≠ÿ©*\n\n"
                        "Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ŸÉŸàŸÜ ÿßŸÑÿ£ŸÉŸàÿßÿØ 16 ÿ≠ÿ±ŸÅÿßŸã (ÿ£ÿ≠ÿ±ŸÅ ŸÉÿ®Ÿäÿ±ÿ© Ÿàÿ£ÿ±ŸÇÿßŸÖ ŸÅŸÇÿ∑)",
                        parse_mode='Markdown',
                        reply_markup=create_main_keyboard(message.from_user.id))
        return False
    
    report_msg = f"""
üîç *ÿ™ŸÇÿ±Ÿäÿ± ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ£ŸàŸÑŸä:*

‚Ä¢ üìã ÿßŸÑÿπÿØÿØ ÿßŸÑÿ•ÿ¨ŸÖÿßŸÑŸä: {len(valid_codes) + len(skipped_codes)}
‚Ä¢ ‚úÖ ÿßŸÑÿµÿßŸÑÿ≠ÿ© ŸÑŸÑŸÖÿπÿßŸÑÿ¨ÿ©: {len(valid_codes)}
‚Ä¢ ‚è≠Ô∏è ÿ≥Ÿäÿ™ŸÖ ÿ™ÿÆÿ∑ŸäŸáÿß: {len(skipped_codes)}
    """
    
    if skipped_codes:
        skipped_list = []
        for code, status in skipped_codes[:5]:
            if status == 'success':
                status_text = "‚úÖ ÿ™ŸÖ ÿßÿ≥ÿ™ÿ±ÿØÿßÿØŸá ÿ®ŸÜÿ¨ÿßÿ≠ ŸÖÿ≥ÿ®ŸÇÿßŸã"
            elif status == 'already_redeemed':
                status_text = "‚ö†Ô∏è ŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÖÿ≥ÿ®ŸÇÿßŸã ŸÅŸä Binance"
            elif status == 'failed':
                status_text = "‚ùå ŸÅÿ¥ŸÑ ŸÅŸä ÿßŸÑÿßÿ≥ÿ™ÿ±ÿØÿßÿØ ŸÖÿ≥ÿ®ŸÇÿßŸã"
            else:
                status_text = f"‚è≠Ô∏è {status}"
            
            skipped_list.append(f"‚Ä¢ {code} ({status_text})")
        
        if len(skipped_codes) > 5:
            skipped_list.append(f"‚Ä¢ ... Ÿà {len(skipped_codes) - 5} ÿ£ÿÆÿ±Ÿâ")
        
        report_msg += f"\n\nüìù *ÿßŸÑÿ£ŸÉŸàÿßÿØ ÿßŸÑŸÖÿ™ÿÆÿ∑ÿßÿ©:*\n" + "\n".join(skipped_list)
    
    if valid_codes:
        valid_list = "\n".join([f"‚Ä¢ {code}" for code in valid_codes[:3]])
        if len(valid_codes) > 3:
            valid_list += f"\n‚Ä¢ ... Ÿà {len(valid_codes) - 3} ÿ£ÿÆÿ±Ÿâ"
        
        report_msg += f"\n\nüéØ *ÿßŸÑÿ£ŸÉŸàÿßÿØ ÿßŸÑÿ™Ÿä ÿ≥Ÿäÿ™ŸÖ ŸÖÿπÿßŸÑÿ¨ÿ™Ÿáÿß:*\n{valid_list}"
    
    bot.send_message(message.chat.id, report_msg, parse_mode='Markdown')
    
    if not valid_codes:
        bot.send_message(message.chat.id,
                        "‚ö†Ô∏è *ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ£ŸÉŸàÿßÿØ ÿ¨ÿØŸäÿØÿ© ŸÑŸÑŸÖÿπÿßŸÑÿ¨ÿ©*",
                        parse_mode='Markdown',
                        reply_markup=create_main_keyboard(message.from_user.id))
        return False
    
    return True

def redeem_gift_card(code, retries=None):
    if retries is None:
        retries = int(redemption_logger.get_setting('max_retries', 4))
    
    binance_limiter.wait_if_needed()
    
    cached_result = cache_system.get(f"code_{code}")
    if cached_result and cached_result.get('from_db') != True:
        logger.info(f"ÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ© ÿßŸÑŸÖÿÆÿ≤ŸÜÿ© ŸÖÿ§ŸÇÿ™Ÿãÿß ŸÑŸÑŸÉŸàÿØ: {code}")
        return cached_result
    
    try:
        api_key = os.getenv('API_KEY')
        api_secret = os.getenv('API_SECRET')
        
        if not api_key or not api_secret or api_key in ['ŸÖŸÅÿ™ÿßÿ≠_Binance_API_ŸáŸÜÿß', 'API_KEY']:
            return {
                'success': False,
                'error': 'ŸÖŸÅÿßÿ™Ÿäÿ≠ API ÿ∫Ÿäÿ± ŸÖÿπŸäŸÜÿ©',
                'error_type': 'api_keys_not_set'
            }
        
        base_url = "https://api.binance.com"
        endpoint = "/sapi/v1/giftcard/redeemCode"
        
        for attempt in range(retries):
            try:
                params = {
                    'code': code,
                    'timestamp': int(time.time() * 1000)
                }
                
                query_string = urlencode(params)
                signature = create_binance_signature(api_secret, query_string)
                params['signature'] = signature
                
                headers = {
                    'X-MBX-APIKEY': api_key,
                    'Content-Type': 'application/json',
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                }
                
                timeout = 15 if attempt == 0 else 25
                
                response = requests.post(
                    f"{base_url}{endpoint}",
                    params=params,
                    headers=headers,
                    timeout=timeout
                )
                
                if response.status_code == 429:
                    wait_time = 10 + (attempt * 5)
                    logger.warning(f"‚è∞ Rate limit ŸÑŸÑŸÉŸàÿØ {code}, ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ± {wait_time} ÿ´ÿßŸÜŸäÿ©")
                    time.sleep(wait_time)
                    continue
                    
                elif response.status_code >= 500:
                    wait_time = 5 + (attempt * 3)
                    logger.warning(f"üåê ÿÆÿ∑ÿ£ ÿÆÿßÿØŸÖ ŸÑŸÑŸÉŸàÿØ {code}, ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ± {wait_time} ÿ´ÿßŸÜŸäÿ©")
                    time.sleep(wait_time)
                    continue
                
                result = response.json()
                
                if result.get('success'):
                    success_data = {
                        'success': True,
                        'data': result.get('data', {}),
                        'already_redeemed': False,
                        'invalid_code': False
                    }
                    cache_system.set(f"code_{code}", success_data, expiry_seconds=86400)
                    return success_data
                    
                else:
                    error_msg = result.get('message', '').lower()
                    
                    if 'already redeemed' in error_msg:
                        return {
                            'success': False,
                            'already_redeemed': True,
                            'error': 'ÿ™ŸÖ ÿßÿ≥ÿ™ÿ±ÿØÿßÿØŸá ŸÖÿ≥ÿ®ŸÇÿßŸã'
                        }
                    elif 'invalid' in error_msg:
                        return {
                            'success': False,
                            'invalid_code': True,
                            'error': 'ŸÉŸàÿØ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠'
                        }
                    else:
                        if attempt < retries - 1:
                            wait_time = 3 + (attempt * 2)
                            logger.warning(f"üîÑ ŸÖÿ≠ÿßŸàŸÑÿ© {attempt + 2} ŸÑŸÑŸÉŸàÿØ {code}, ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ± {wait_time} ÿ´ÿßŸÜŸäÿ©")
                            time.sleep(wait_time)
                            continue
                        else:
                            return {
                                'success': False,
                                'error': result.get('message', 'ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ')
                            }
                
            except requests.exceptions.Timeout:
                if attempt < retries - 1:
                    wait_time = 8 + (attempt * 3)
                    logger.warning(f"‚åõ timeout ŸÑŸÑŸÉŸàÿØ {code}, ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© {attempt + 2}")
                    time.sleep(wait_time)
                    continue
                else:
                    return {
                        'success': False,
                        'error': 'ÿßŸÜÿ™Ÿáÿ™ ŸÖŸáŸÑÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ'
                    }
                    
            except Exception as e:
                if attempt < retries - 1:
                    wait_time = 4 + (attempt * 2)
                    logger.warning(f"‚ö†Ô∏è ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑŸÉŸàÿØ {code}, ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© {attempt + 2}")
                    time.sleep(wait_time)
                    continue
                else:
                    return {
                        'success': False,
                        'error': str(e)
                    }
                    
    except Exception as e:
        logger.error(f"ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ ŸÅŸä ÿßÿ≥ÿ™ÿ±ÿØÿßÿØ ÿßŸÑŸÉŸàÿØ {code}: {str(e)}")
        return {
            'success': False,
            'error': str(e)
        }

def send_admin_report(user, codes_data, redemption_type="single"):
    try:
        if ADMIN_USER_ID == 0:
            return
        
        user_info = f"üë§ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ: {user.first_name}"
        if user.username:
            user_info += f" (@{user.username})"
        user_info += f"\nüÜî ÿßŸÑÿßŸäÿØŸä: {user.id}"
        
        if redemption_type == "single":
            code_data = codes_data[0]
            report_message = f"""
üìã *ÿ™ŸÇÿ±Ÿäÿ± ÿßÿ≥ÿ™ÿ±ÿØÿßÿØ ÿ¨ÿØŸäÿØ*

{user_info}
‚Ä¢ ÿßŸÑŸÉŸàÿØ: `{code_data['code']}`
‚Ä¢ ÿßŸÑÿ≠ÿßŸÑÿ©: {code_data['status']}
‚Ä¢ ÿßŸÑŸÖÿ®ŸÑÿ∫: {code_data['amount']} {code_data['currency']}
‚Ä¢ ÿßŸÑŸàŸÇÿ™: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
            """
        else:
            total_codes = len(codes_data)
            success_count = sum(1 for code in codes_data if code['status'] == 'success')
            already_redeemed_count = sum(1 for code in codes_data if code['status'] == 'already_redeemed')
            failed_count = sum(1 for code in codes_data if code['status'] == 'failed')
            total_amount = sum(float(code['amount']) for code in codes_data if code['status'] == 'success')
            
            report_message = f"""
üìä *ÿ™ŸÇÿ±Ÿäÿ± ÿßÿ≥ÿ™ÿ±ÿØÿßÿØ ÿ¨ŸÖÿßÿπŸä*

{user_info}
‚Ä¢ üì¶ ÿßŸÑÿπÿØÿØ ÿßŸÑÿ•ÿ¨ŸÖÿßŸÑŸä: {total_codes}
‚Ä¢ ‚úÖ ÿßŸÑŸÜÿßÿ¨ÿ≠ÿ©: {success_count}
‚Ä¢ ‚ö†Ô∏è ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖÿ© ŸÖÿ≥ÿ®ŸÇÿßŸã: {already_redeemed_count}
‚Ä¢ ‚ùå ÿßŸÑŸÅÿßÿ¥ŸÑÿ©: {failed_count}
‚Ä¢ üí∞ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑÿ•ÿ¨ŸÖÿßŸÑŸä: {total_amount:.2f} USDT
‚Ä¢ üïí ÿßŸÑŸàŸÇÿ™: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

üìù *ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿ£ŸÉŸàÿßÿØ:*
"""
            for i, code_data in enumerate(codes_data[:10]):
                status_icon = "‚úÖ" if code_data['status'] == 'success' else "‚ö†Ô∏è" if code_data['status'] == 'already_redeemed' else "‚ùå"
                report_message += f"\n{i+1}. {status_icon} `{code_data['code']}` - {code_data['amount']} {code_data['currency']}"
            
            if total_codes > 10:
                report_message += f"\n‚Ä¢ ... Ÿà {total_codes - 10} ŸÉŸàÿØ ÿ£ÿÆÿ±Ÿâ"
        
        bot.send_message(ADMIN_USER_ID, report_message, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ™ŸÇÿ±Ÿäÿ± ÿ•ŸÑŸâ ÿßŸÑŸÖÿØŸäÿ±: {str(e)}")

def handle_bot_error(chat_id, error_message=None):
    error_msg = """
üî¥ *ÿßŸÑÿÆÿØŸÖÿ© ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±ÿ© ÿßŸÑÿ£ŸÜ*
ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÑÿßÿ≠ŸÇÿßŸã
    """
    
    try:
        bot.send_message(chat_id, error_msg, parse_mode='Markdown')
    except Exception as e:
        logger.error(f"‚ùå ŸÅÿ¥ŸÑ ŸÅŸä ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿÆÿ∑ÿ£: {e}")

def global_error_handler(func):
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except Exception as e:
            logger.error(f"‚ùå ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ ŸÅŸä {func.__name__}: {e}")
            
            chat_id = None
            for arg in args:
                if hasattr(arg, 'chat') and hasattr(arg.chat, 'id'):
                    chat_id = arg.chat.id
                    break
                elif hasattr(arg, 'chat_id'):
                    chat_id = arg.chat_id
                    break
            
            if chat_id:
                handle_bot_error(chat_id, str(e))
            
            return None
    return wrapper

@global_error_handler
def process_single_code_async(message, code):
    try:
        processing_msg = bot.send_message(message.chat.id, 
                                        f"‚è≥ ÿ¨ÿßÿ±Ÿä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÉŸàÿØ: `{code}`...",
                                        parse_mode='Markdown')
        
        result = redeem_gift_card(code)
        username = message.from_user.username or message.from_user.first_name
        
        if result.get('success'):
            amount_data = result.get('data', {}).get('amount', 0)
            currency = result.get('data', {}).get('currency', 'USDT')
            
            try:
                amount = float(amount_data)
            except (ValueError, TypeError):
                amount = 0.0
            
            redemption_logger.log_redemption(
                message.from_user.id, username, code, amount, currency, 'success'
            )
            
            response = f"""
‚úÖ *ÿ™ŸÖ ÿßŸÑÿßÿ≥ÿ™ÿ±ÿØÿßÿØ ÿ®ŸÜÿ¨ÿßÿ≠!*

üìã *ÿßŸÑÿ™ŸÅÿßÿµŸäŸÑ:*
‚Ä¢ ÿßŸÑŸÉŸàÿØ: `{code}`
‚Ä¢ ÿßŸÑŸÖÿ®ŸÑÿ∫: *{amount} {currency}*
‚Ä¢ ÿßŸÑÿ≠ÿßŸÑÿ©: ŸÜÿßÿ¨ÿ≠ ‚úÖ
            """
            
            send_admin_report(message.from_user, [{
                'code': code,
                'status': 'success',
                'amount': amount,
                'currency': currency
            }])
            
        elif result.get('already_redeemed'):
            redemption_logger.log_redemption(
                message.from_user.id, username, code, 0.0, 'USD', 'already_redeemed'
            )
            
            response = f"""
‚ö†Ô∏è *ÿßŸÑŸÉŸàÿØ ÿ™ŸÖ ÿßÿ≥ÿ™ÿ±ÿØÿßÿØŸá ŸÖÿ≥ÿ®ŸÇÿßŸã*

‚Ä¢ ÿßŸÑŸÉŸàÿØ: `{code}`
‚Ä¢ ÿßŸÑÿ≠ÿßŸÑÿ©: ŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ≥ÿßÿ®ŸÇÿßŸã ‚ö†Ô∏è
‚Ä¢ ÿßŸÑŸÖÿ®ŸÑÿ∫: 0.00 USDT (ÿ™ŸÖ ÿßÿ≥ÿ™ÿ±ÿØÿßÿØŸá ŸÖÿ≥ÿ®ŸÇÿßŸã)
            """
            
            send_admin_report(message.from_user, [{
                'code': code,
                'status': 'already_redeemed',
                'amount': 0.0,
                'currency': 'USD'
            }])
            
        else:
            error_msg = result.get('error', 'ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ')
            
            redemption_logger.log_redemption(
                message.from_user.id, username, code, 0.0, 'USD', 'failed'
            )
            
            response = f"""
‚ùå *ŸÅÿ¥ŸÑ ÿßŸÑÿßÿ≥ÿ™ÿ±ÿØÿßÿØ*

‚Ä¢ ÿßŸÑŸÉŸàÿØ: `{code}`
‚Ä¢ ÿßŸÑÿÆÿ∑ÿ£: {error_msg}
            """
            
            send_admin_report(message.from_user, [{
                'code': code,
                'status': 'failed',
                'amount': 0.0,
                'currency': 'USD',
                'error': error_msg
            }])
        
        bot.send_message(message.chat.id, response, 
                        parse_mode='Markdown',
                        reply_markup=create_main_keyboard(message.from_user.id))
        
        try:
            bot.delete_message(message.chat.id, processing_msg.message_id)
        except:
            pass
            
    except Exception as e:
        logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÉŸàÿØ {code}: {str(e)}")
        handle_bot_error(message.chat.id, str(e))

@global_error_handler
def process_multiple_codes_async(message, codes):
    try:
        MAX_CODES = int(redemption_logger.get_setting('max_codes_per_message', 30))
        if len(codes) > MAX_CODES:
            codes = codes[:MAX_CODES]
            bot.send_message(message.chat.id,
                            f"‚ö†Ô∏è *ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ*\n"
                            f"ÿ™ŸÖ ÿßÿÆÿ™Ÿäÿßÿ± ÿ£ŸàŸÑ {MAX_CODES} ŸÉŸàÿØ ŸÅŸÇÿ∑",
                            parse_mode='Markdown')
        
        total_codes = len(codes)
        processing_msg = bot.send_message(message.chat.id, 
                                        f"‚è≥ ÿ¨ÿßÿ±Ÿä ŸÖÿπÿßŸÑÿ¨ÿ© {total_codes} ŸÉŸàÿØ...",
                                        parse_mode='Markdown')
        
        results = []
        success_count = 0
        already_redeemed_count = 0
        failed_count = 0
        total_amount = 0.0
        
        for i, code in enumerate(codes, 1):
            try:
                progress = (i / total_codes) * 100
                try:
                    bot.edit_message_text(
                        f"‚è≥ ÿ¨ÿßÿ±Ÿä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÉŸàÿØ {i} ŸÖŸÜ {total_codes}\n"
                        f"üìä ÿßŸÑÿ™ŸÇÿØŸÖ: {progress:.1f}%\n"
                        f"‚úÖ ÿßŸÑŸÜÿßÿ¨ÿ≠ÿ©: {success_count} | ‚ö†Ô∏è ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖÿ©: {already_redeemed_count} | ‚ùå ÿßŸÑŸÅÿßÿ¥ŸÑÿ©: {failed_count}\n"
                        f"üí∞ ÿßŸÑŸÖÿ¨ŸÖŸàÿπ: {total_amount:.2f} USDT",
                        message.chat.id,
                        processing_msg.message_id
                    )
                except:
                    pass
                
                result = redeem_gift_card(code)
                results.append((code, result))
                
                username = message.from_user.username or message.from_user.first_name
                
                if result.get('success'):
                    amount = float(result.get('data', {}).get('amount', 0))
                    currency = result.get('data', {}).get('currency', 'USDT')
                    
                    success_count += 1
                    total_amount += amount
                    redemption_logger.log_redemption(
                        message.from_user.id, username, code, amount, currency, 'success'
                    )
                    
                elif result.get('already_redeemed'):
                    already_redeemed_count += 1
                    redemption_logger.log_redemption(
                        message.from_user.id, username, code, 0.0, 'USD', 'already_redeemed'
                    )
                    
                else:
                    failed_count += 1
                    redemption_logger.log_redemption(
                        message.from_user.id, username, code, 0.0, 'USD', 'failed'
                    )
                
                time.sleep(0.8)
                
            except Exception as e:
                logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÉŸàÿØ {code}: {str(e)}")
                failed_count += 1
                results.append((code, {'error': str(e), 'success': False}))
                time.sleep(1.5)
        
        admin_report_data = []
        for code, result in results:
            if result.get('success'):
                amount_data = result.get('data', {}).get('amount', 0)
                currency = result.get('data', {}).get('currency', 'USDT')
                try:
                    amount = float(amount_data)
                except (ValueError, TypeError):
                    amount = 0.0
                admin_report_data.append({
                    'code': code,
                    'status': 'success',
                    'amount': amount,
                    'currency': currency
                })
            elif result.get('already_redeemed'):
                admin_report_data.append({
                    'code': code,
                    'status': 'already_redeemed',
                    'amount': 0.0,
                    'currency': 'USD'
                })
            else:
                admin_report_data.append({
                    'code': code,
                    'status': 'failed',
                    'amount': 0.0,
                    'currency': 'USD'
                })
        
        send_admin_report(message.from_user, admin_report_data, "multiple")
        
        total_processed = success_count + already_redeemed_count + failed_count
        
        summary = f"""
üìä *ÿ™ŸÇÿ±Ÿäÿ± ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©:*

‚Ä¢ üì¶ ÿßŸÑÿπÿØÿØ ÿßŸÑÿ•ÿ¨ŸÖÿßŸÑŸä: {total_codes}
‚Ä¢ ‚úÖ ÿßŸÑŸÜÿßÿ¨ÿ≠ÿ©: {success_count}
‚Ä¢ ‚ö†Ô∏è ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖÿ© ŸÖÿ≥ÿ®ŸÇÿßŸã: {already_redeemed_count}
‚Ä¢ ‚ùå ÿßŸÑŸÅÿßÿ¥ŸÑÿ©: {failed_count}
‚Ä¢ üí∞ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑÿ•ÿ¨ŸÖÿßŸÑŸä: {total_amount:.2f} USDT
        """
        
        bot.send_message(message.chat.id, summary, parse_mode='Markdown')
        
        final_msg = f"""
üéØ *ŸÖÿπÿßŸÑÿ¨ÿ© ŸÖŸÉÿ™ŸÖŸÑÿ©!*

üìä ŸÑŸÖÿ¥ÿßŸáÿØÿ© ÿßŸÑÿ≥ÿ¨ŸÑ: ÿßÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ "üìä ÿßÿ≥ÿ™ÿ±ÿØÿßÿØÿßÿ™Ÿä"
        """
        
        bot.send_message(message.chat.id, final_msg,
                        parse_mode='Markdown',
                        reply_markup=create_main_keyboard(message.from_user.id))
        
        try:
            bot.delete_message(message.chat.id, processing_msg.message_id)
        except:
            pass
            
    except Exception as e:
        logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ£ŸÉŸàÿßÿØ ÿßŸÑŸÖÿ™ÿπÿØÿØÿ©: {str(e)}")
        handle_bot_error(message.chat.id, str(e))

def create_main_keyboard(user_id):
    keyboard = ReplyKeyboardMarkup(resize_keyboard=True)
    keyboard.row(KeyboardButton("üéÅ ÿßÿ≥ÿ™ÿ±ÿØÿßÿØ ŸÉŸàÿØ"))
    keyboard.row(KeyboardButton("üìä ÿßÿ≥ÿ™ÿ±ÿØÿßÿØÿßÿ™Ÿä"), KeyboardButton("‚ÑπÔ∏è ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ©"))
    
    if user_id == ADMIN_USER_ID:
        keyboard.row(KeyboardButton("üë®‚Äçüíª ŸÑŸàÿ≠ÿ© ÿßŸÑÿ™ÿ≠ŸÉŸÖ"))
    
    return keyboard

def create_admin_keyboard():
    keyboard = ReplyKeyboardMarkup(resize_keyboard=True)
    keyboard.row(KeyboardButton("üìà ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™"), KeyboardButton("‚öôÔ∏è ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™"))
    keyboard.row(KeyboardButton("üì§ ÿ™ÿµÿØŸäÿ± ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™"), KeyboardButton("üßπ ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™"))
    keyboard.row(KeyboardButton("üì¢ ÿ®ÿ´ ÿ¨ŸÖÿßÿπŸä"))  # ÿßŸÑÿ≤ÿ± ÿßŸÑÿ¨ÿØŸäÿØ
    keyboard.row(KeyboardButton("üîô ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©"))
    return keyboard

@global_error_handler
def send_welcome(message):
    redemption_logger.log_request(message.from_user.id, 'start')
    
    allowed, error_msg = rate_limit_check(message.from_user.id)
    if not allowed:
        bot.send_message(message.chat.id, error_msg)
        return
    
    welcome_text = """
üåü *ŸÖÿ±ÿ≠ÿ®ÿßŸã ÿ®ŸÉ ŸÅŸä ÿ®Ÿàÿ™ ÿßÿ≥ÿ™ÿ±ÿØÿßÿØ ÿ£ŸÉŸàÿßÿØ Binance ÿßŸÑÿßÿ≠ÿ™ÿ±ÿßŸÅŸä!* üåü

‚ö° *ŸÖŸÖŸäÿ≤ÿßÿ™ ÿßŸÑÿ®Ÿàÿ™:*
‚Ä¢ ‚úÖ ÿßÿ≥ÿ™ÿ±ÿØÿßÿØ ÿ£ŸÉŸàÿßÿØ Binance ÿ®ÿ≥ÿ±ÿπÿ© Ÿàÿßÿ≠ÿ™ÿ±ÿßŸÅŸäÿ©
‚Ä¢ üìä ÿ™ÿ™ÿ®ÿπ ÿ¨ŸÖŸäÿπ ÿπŸÖŸÑŸäÿßÿ™ ÿßŸÑÿßÿ≥ÿ™ÿ±ÿØÿßÿØ ÿ®ÿ¥ŸÉŸÑ ŸÖŸÅÿµŸÑ
‚Ä¢ üõ°Ô∏è ŸÜÿ∏ÿßŸÖ ÿ¢ŸÖŸÜ Ÿäÿ≠ÿßŸÅÿ∏ ÿπŸÑŸâ ÿÆÿµŸàÿµŸäÿ™ŸÉ
‚Ä¢ ‚ö° ŸÖÿπÿßŸÑÿ¨ÿ© ŸÖÿ™ÿπÿØÿØÿ© ŸÑŸÑÿ£ŸÉŸàÿßÿØ ŸÅŸä ŸàŸÇÿ™ Ÿàÿßÿ≠ÿØ

üìù *ŸÉŸäŸÅŸäÿ© ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ:*
1. ÿ£ÿ±ÿ≥ŸÑ ŸÉŸàÿØ ÿßŸÑŸáÿØŸäÿ© (16 ÿ≠ÿ±ŸÅÿßŸã) ÿ£Ÿà ÿπÿØÿ© ÿ£ŸÉŸàÿßÿØ
2. ÿßŸÜÿ™ÿ∏ÿ± ÿ≠ÿ™Ÿâ ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©
3. ÿßÿ≠ÿµŸÑ ÿπŸÑŸâ ÿ™ŸÇÿ±Ÿäÿ± ŸÖŸÅÿµŸÑ ÿ®ŸÜÿ™ÿßÿ¶ÿ¨ ÿßŸÑÿßÿ≥ÿ™ÿ±ÿØÿßÿØ

‚ö° *ŸÜÿµÿßÿ¶ÿ≠ ŸÑŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ£ŸÖÿ´ŸÑ:*
- ÿ£ÿ±ÿ≥ŸÑ 10-20 ŸÉŸàÿØ ŸÅŸä ŸÉŸÑ ÿ±ÿ≥ÿßŸÑÿ© ŸÑŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ£ŸÅÿ∂ŸÑ ÿ£ÿØÿßÿ°
- ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿµÿ≠ÿ© formato ÿßŸÑÿ£ŸÉŸàÿßÿØ (16 ÿ≠ÿ±ŸÅÿßŸãÿå ÿ£ÿ≠ÿ±ŸÅ ŸÉÿ®Ÿäÿ±ÿ© Ÿàÿ£ÿ±ŸÇÿßŸÖ ŸÅŸÇÿ∑)
- ÿßŸÜÿ™ÿ∏ÿ± ÿ≠ÿ™Ÿâ ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© ŸÇÿ®ŸÑ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÖÿ≤ŸäÿØ

üì¶ *ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ: 30 ŸÉŸàÿØ ŸÅŸä ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸàÿßÿ≠ÿØÿ©*

üîí *ÿÆÿµŸàÿµŸäÿ™ŸÉ ŸÖŸáŸÖÿ© ŸÑŸÜÿß:* ŸÑÿß Ÿäÿ™ŸÖ ÿ™ÿÆÿ≤ŸäŸÜ ÿ£Ÿä ÿ®ŸäÿßŸÜÿßÿ™ ÿ¥ÿÆÿµŸäÿ©
    """
    
    bot.send_message(message.chat.id, welcome_text, 
                    parse_mode='Markdown', 
                    reply_markup=create_main_keyboard(message.from_user.id))

@global_error_handler
def help_menu(message):
    redemption_logger.log_request(message.from_user.id, 'help')
    
    allowed, error_msg = rate_limit_check(message.from_user.id)
    if not allowed:
        bot.send_message(message.chat.id, error_msg)
        return
    
    help_text = """
üìñ *ÿØŸÑŸäŸÑ ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ:*

üéÅ *ŸÉŸäŸÅŸäÿ© ÿßŸÑÿßÿ≥ÿ™ÿ±ÿØÿßÿØ:*
- ÿ£ÿ±ÿ≥ŸÑ ŸÉŸàÿØ ÿßŸÑŸáÿØŸäÿ© (16 ÿ≠ÿ±ŸÅÿßŸã)
- ÿ£Ÿà ÿ£ÿ±ÿ≥ŸÑ ÿπÿØÿ© ÿ£ŸÉŸàÿßÿØ ŸÖÿπÿßŸã

üìä *ŸÑŸÖÿπÿ±ŸÅÿ© ÿßŸÑÿ≥ÿ¨ŸÑ:*
- ÿßÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ "üìä ÿßÿ≥ÿ™ÿ±ÿØÿßÿØÿßÿ™Ÿä"

‚ö†Ô∏è *ŸÖŸÑÿßÿ≠ÿ∏ÿßÿ™:*
- ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© ŸÇÿØ ÿ™ÿ≥ÿ™ÿ∫ÿ±ŸÇ ŸàŸÇÿ™ÿßŸã
- ÿ®ÿπÿ∂ ÿßŸÑÿ£ŸÉŸàÿßÿØ ŸÇÿØ ŸÑÿß ÿ™ÿπŸÖŸÑ
- ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ 30 ŸÉŸàÿØ ŸÅŸä ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©
    """
    bot.send_message(message.chat.id, help_text, 
                    parse_mode='Markdown',
                    reply_markup=create_main_keyboard(message.from_user.id))

@global_error_handler
def show_redemptions(message):
    redemption_logger.log_request(message.from_user.id, 'my_redemptions')
    
    allowed, error_msg = rate_limit_check(message.from_user.id)
    if not allowed:
        bot.send_message(message.chat.id, error_msg)
        return
    
    try:
        redemptions = redemption_logger.get_user_redemptions(message.from_user.id)
        
        if not redemptions:
            bot.send_message(message.chat.id, 
                            "üì≠ ŸÑŸÖ ÿ™ŸÇŸÖ ÿ®ÿ£Ÿä ÿπŸÖŸÑŸäÿßÿ™ ÿßÿ≥ÿ™ÿ±ÿØÿßÿØ ÿ®ÿπÿØ",
                            reply_markup=create_main_keyboard(message.from_user.id))
            return
        
        redemption_list = []
        total_success = 0.0
        success_count = 0
        already_redeemed_count = 0
        
        for i, (code, amount, currency, status, timestamp) in enumerate(redemptions, 1):
            if status == 'success':
                status_icon = "‚úÖ"
                total_success += float(amount)
                success_count += 1
            elif status == 'already_redeemed':
                status_icon = "‚ö†Ô∏è"
                already_redeemed_count += 1
            else:
                status_icon = "‚ùå"
            
            date_str = timestamp.split()[0] if isinstance(timestamp, str) else timestamp[:10]
            redemption_list.append(f"{i}. {status_icon} {code} - {amount} {currency} - {status}")
        
        response = f"""
üìã *ÿ≥ÿ¨ŸÑ ÿßÿ≥ÿ™ÿ±ÿØÿßÿØÿßÿ™ŸÉ:*

{chr(10).join(redemption_list)}

üí∞ *ÿßŸÑÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑŸÜÿßÿ¨ÿ≠:* {total_success:.2f} USDT
üéØ *ÿπÿØÿØ ÿßŸÑŸÜÿ¨ÿßÿ≠ÿßÿ™:* {success_count}
‚ö†Ô∏è *ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖÿ© ŸÖÿ≥ÿ®ŸÇÿßŸã:* {already_redeemed_count}
        """
        bot.send_message(message.chat.id, response, 
                        parse_mode='Markdown',
                        reply_markup=create_main_keyboard(message.from_user.id))
        
    except Exception as e:
        logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿ¨ŸÑÿ® ÿ≥ÿ¨ŸÑ ÿßŸÑÿßÿ≥ÿ™ÿ±ÿØÿßÿØÿßÿ™: {str(e)}")
        handle_bot_error(message.chat.id, str(e))

@global_error_handler
def ask_for_code(message):
    redemption_logger.log_request(message.from_user.id, 'redeem_code')
    
    allowed, error_msg = rate_limit_check(message.from_user.id)
    if not allowed:
        bot.send_message(message.chat.id, error_msg)
        return
    
    help_text = """
üéÅ *ÿßÿ≥ÿ™ÿ±ÿØÿßÿØ ÿ£ŸÉŸàÿßÿØ Binance*

ŸäŸÖŸÉŸÜŸÉ ÿ•ÿ±ÿ≥ÿßŸÑ:
- ŸÉŸàÿØ Ÿàÿßÿ≠ÿØ ŸÅŸÇÿ∑
- ÿ£Ÿà ÿπÿØÿ© ÿ£ŸÉŸàÿßÿØ ŸÖÿπÿßŸã ŸÅŸä ŸÜŸÅÿ≥ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©

‚ö° *ŸÖŸÑÿßÿ≠ÿ∏ÿ© ŸÖŸáŸÖÿ©:*
- ÿßŸÑŸÉŸàÿØ Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ 16 ÿ≠ÿ±ŸÅÿßŸã (ÿ£ÿ≠ÿ±ŸÅ ÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ© ŸÉÿ®Ÿäÿ±Ÿá Ÿàÿ£ÿ±ŸÇÿßŸÖ ŸÅŸÇÿ∑)
- ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ 30 ŸÉŸàÿØ ŸÅŸä ŸÉŸÑ ŸÖÿ±ÿ©

üì§ **ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑÿ£ŸÉŸàÿßÿØ ÿßŸÑÿ¢ŸÜ ŸÑÿ®ÿØÿ° ÿßŸÑÿßÿ≥ÿ™ÿ±ÿØÿßÿØ**
    """
    
    bot.send_message(message.chat.id, help_text, 
                    parse_mode='Markdown',
                    reply_markup=create_main_keyboard(message.from_user.id))

@global_error_handler
def admin_panel(message):
    bot.send_message(message.chat.id, "ŸÖÿ±ÿ≠ÿ®ÿßŸã ÿ®ŸÉ ŸÅŸä ŸÑŸàÿ≠ÿ© ÿßŸÑÿ™ÿ≠ŸÉŸÖ ÿßŸÑÿ•ÿØÿßÿ±Ÿäÿ©", reply_markup=create_admin_keyboard())

@global_error_handler
def admin_back_to_main(message):
    bot.send_message(message.chat.id, "ÿ™ŸÖ ÿßŸÑÿπŸàÿØÿ© ÿ•ŸÑŸâ ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©", reply_markup=create_main_keyboard(message.from_user.id))

@global_error_handler
def admin_statistics(message):
    try:
        today_stats = redemption_logger.get_daily_statistics()
        weekly_stats = redemption_logger.get_multiple_days_statistics(7)
        
        weekly_totals = {
            'total_redemptions': sum(day['total_redemptions'] for day in weekly_stats),
            'successful_redemptions': sum(day['successful_redemptions'] for day in weekly_stats),
            'total_amount': sum(day['total_amount'] for day in weekly_stats),
            'unique_users': len(set(day['date'] for day in weekly_stats))
        }
        
        response = f"""
üìä *ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ•ÿØÿßÿ±Ÿäÿ© - ÿßŸÑŸäŸàŸÖ*

‚Ä¢ üìÖ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ: {today_stats['date']}
‚Ä¢ üì¶ ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿßÿ™: {today_stats['total_redemptions']}
‚Ä¢ ‚úÖ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿßÿ™ ÿßŸÑŸÜÿßÿ¨ÿ≠ÿ©: {today_stats['successful_redemptions']}
‚Ä¢ üí∞ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑÿ•ÿ¨ŸÖÿßŸÑŸä: {today_stats['total_amount']:.2f} USDT
‚Ä¢ üë• ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸàŸÜ ÿßŸÑŸÅÿ±ŸäÿØŸàŸÜ: {today_stats['unique_users']}

üìà *ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿ¢ÿÆÿ± 7 ÿ£ŸäÿßŸÖ:*
‚Ä¢ üì¶ ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿßÿ™: {weekly_totals['total_redemptions']}
‚Ä¢ ‚úÖ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿßÿ™ ÿßŸÑŸÜÿßÿ¨ÿ≠ÿ©: {weekly_totals['successful_redemptions']}
‚Ä¢ üí∞ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑÿ•ÿ¨ŸÖÿßŸÑŸä: {weekly_totals['total_amount']:.2f} USDT

‚öôÔ∏è *ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ≠ÿßŸÑŸäÿ©:*
‚Ä¢ ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ/ÿßŸÑÿØŸÇŸäŸÇÿ©: {redemption_logger.get_setting('rate_limit_minute')}
‚Ä¢ ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ/ÿßŸÑÿ≥ÿßÿπÿ©: {redemption_logger.get_setting('rate_limit_hour')}
‚Ä¢ ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ/ÿßŸÑŸäŸàŸÖ: {redemption_logger.get_setting('rate_limit_day')}
        """
        
        bot.send_message(message.chat.id, response, parse_mode='Markdown', reply_markup=create_admin_keyboard())
        
    except Exception as e:
        logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿ¨ŸÑÿ® ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™: {str(e)}")
        handle_bot_error(message.chat.id, str(e))

@global_error_handler
def admin_settings(message):
    try:
        keyboard = InlineKeyboardMarkup()
        keyboard.row(
            InlineKeyboardButton("ÿ≠ÿØ ÿßŸÑÿØŸÇŸäŸÇÿ©", callback_data="setting_minute"),
            InlineKeyboardButton("ÿ≠ÿØ ÿßŸÑÿ≥ÿßÿπÿ©", callback_data="setting_hour")
        )
        keyboard.row(
            InlineKeyboardButton("ÿ≠ÿØ ÿßŸÑŸäŸàŸÖ", callback_data="setting_day"),
            InlineKeyboardButton("ÿ£ŸäÿßŸÖ ÿßŸÑÿ™ŸÜÿ∏ŸäŸÅ", callback_data="setting_cleanup")
        )
        keyboard.row(InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data="admin_back"))
        
        settings_text = """
‚öôÔ∏è *ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ≠ÿßŸÑŸäÿ©:*

‚Ä¢ ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑŸÑÿ∑ŸÑÿ®ÿßÿ™ ŸÅŸä ÿßŸÑÿØŸÇŸäŸÇÿ©: {minute}
‚Ä¢ ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑŸÑÿ∑ŸÑÿ®ÿßÿ™ ŸÅŸä ÿßŸÑÿ≥ÿßÿπÿ©: {hour}
‚Ä¢ ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑŸÑÿ∑ŸÑÿ®ÿßÿ™ ŸÅŸä ÿßŸÑŸäŸàŸÖ: {day}
‚Ä¢ ÿ£ŸäÿßŸÖ ÿßŸÑÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä: {cleanup}

ÿßÿÆÿ™ÿ± ÿßŸÑÿ•ÿπÿØÿßÿØ ÿßŸÑÿ∞Ÿä ÿ™ÿ±ŸäÿØ ÿ™ÿπÿØŸäŸÑŸá:
        """.format(
            minute=redemption_logger.get_setting('rate_limit_minute'),
            hour=redemption_logger.get_setting('rate_limit_hour'),
            day=redemption_logger.get_setting('rate_limit_day'),
            cleanup=redemption_logger.get_setting('auto_cleanup_days')
        )
        
        bot.send_message(message.chat.id, settings_text, parse_mode='Markdown', reply_markup=keyboard)
        
    except Exception as e:
        logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿπÿ±ÿ∂ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™: {str(e)}")
        handle_bot_error(message.chat.id, str(e))

@global_error_handler
def admin_export_data(message):
    try:
        keyboard = InlineKeyboardMarkup()
        keyboard.row(
            InlineKeyboardButton("üìä 7 ÿ£ŸäÿßŸÖ", callback_data="export_7"),
            InlineKeyboardButton("üìà 30 ŸäŸàŸÖ", callback_data="export_30")
        )
        keyboard.row(
            InlineKeyboardButton("üóìÔ∏è 90 ŸäŸàŸÖ", callback_data="export_90"),
            InlineKeyboardButton("üìÜ ŸÉŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™", callback_data="export_all")
        )
        keyboard.row(InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data="admin_back"))
        
        bot.send_message(message.chat.id, "üì§ ÿßÿÆÿ™ÿ± ÿßŸÑŸÅÿ™ÿ±ÿ© ÿßŸÑÿ≤ŸÖŸÜŸäÿ© ŸÑŸÑÿ™ÿµÿØŸäÿ±:", reply_markup=keyboard)
        
    except Exception as e:
        logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿµÿØŸäÿ± ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™: {str(e)}")
        handle_bot_error(message.chat.id, str(e))

@global_error_handler
def admin_cleanup_data(message):
    try:
        keyboard = InlineKeyboardMarkup()
        keyboard.row(
            InlineKeyboardButton("üßπ ÿ™ŸÜÿ∏ŸäŸÅ ÿ£ŸÉŸàÿßÿØ 24 ÿ≥ÿßÿπÿ©", callback_data="cleanup_24h_codes"),
            InlineKeyboardButton("üßπ ÿ™ŸÜÿ∏ŸäŸÅ ŸÉÿßŸÖŸÑ", callback_data="cleanup_now")
        )
        keyboard.row(InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data="admin_back"))
        
        conn = sqlite3.connect("processed_codes.db")
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM processed_codes WHERE timestamp >= datetime('now', '-1 day')")
        recent_codes = cursor.fetchone()[0]
        conn.close()
        
        cleanup_text = f"""
üßπ *ÿÆŸäÿßÿ±ÿßÿ™ ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ§ŸÇÿ™*

‚Ä¢ üì¶ ÿßŸÑÿ£ŸÉŸàÿßÿØ ŸÅŸä ÿßŸÑÿ∞ÿßŸÉÿ±ÿ©: {len(cache_system.cache)}
‚Ä¢ üóÉÔ∏è ÿßŸÑÿ£ŸÉŸàÿßÿØ ÿßŸÑŸÖÿ§ŸÇÿ™ÿ© (24h): {recent_codes}

üìä *ÿßÿÆÿ™ÿ± ŸÜŸàÿπ ÿßŸÑÿ™ŸÜÿ∏ŸäŸÅ:*
‚Ä¢ ÿ™ŸÜÿ∏ŸäŸÅ ÿ£ŸÉŸàÿßÿØ 24 ÿ≥ÿßÿπÿ© - Ÿäÿ≠ÿ∞ŸÅ ÿßŸÑÿ£ŸÉŸàÿßÿØ ÿßŸÑÿ≠ÿØŸäÿ´ÿ© ŸÖŸÜ ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ§ŸÇÿ™ ŸÅŸÇÿ∑
‚Ä¢ ÿ™ŸÜÿ∏ŸäŸÅ ŸÉÿßŸÖŸÑ - ÿßŸÑÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿπÿßÿØŸä ŸÑŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÇÿØŸäŸÖÿ©
        """
        
        bot.send_message(message.chat.id, cleanup_text, parse_mode='Markdown', reply_markup=keyboard)
        
    except Exception as e:
        logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿπÿ±ÿ∂ ÿÆŸäÿßÿ±ÿßÿ™ ÿßŸÑÿ™ŸÜÿ∏ŸäŸÅ: {str(e)}")
        handle_bot_error(message.chat.id, str(e))

@global_error_handler
def admin_broadcast(message):
    try:
        if message.text == "üì¢ ÿ®ÿ´ ÿ¨ŸÖÿßÿπŸä":
            msg = bot.send_message(message.chat.id, "ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ™Ÿä ÿ™ÿ±ŸäÿØ ÿ®ÿ´Ÿáÿß ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ:")
            bot.register_next_step_handler(msg, process_broadcast_message)
            return
            
    except Exception as e:
        logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ®ÿ´ ÿßŸÑÿ¨ŸÖÿßÿπŸä: {str(e)}")
        handle_bot_error(message.chat.id, str(e))

@global_error_handler
def process_broadcast_message(message):
    try:
        broadcast_text = message.text
        
        # ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿßŸÑŸÅÿ±ŸäÿØŸäŸÜ ŸÖŸÜ ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
        conn = sqlite3.connect("redemptions.db")
        cursor = conn.cursor()
        cursor.execute('SELECT DISTINCT user_id FROM redemptions')
        user_ids = [row[0] for row in cursor.fetchall()]
        conn.close()
        
        # ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿßŸÑÿ¨ÿØÿØ ÿßŸÑÿ∞ŸäŸÜ ŸÑŸÖ Ÿäÿ≥ÿ™ÿÆÿØŸÖŸàÿß ÿßŸÑÿ®Ÿàÿ™ ÿ®ÿπÿØ
        user_ids.append(ADMIN_USER_ID)
        user_ids = list(set(user_ids))  # ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ™ŸÉÿ±ÿßÿ±ÿßÿ™
        
        success_count = 0
        fail_count = 0
        total_users = len(user_ids)
        
        progress_msg = bot.send_message(message.chat.id, 
                                      f"‚è≥ ÿ¨ÿßÿ±Ÿä ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÑŸÄ {total_users} ŸÖÿ≥ÿ™ÿÆÿØŸÖ...\n\n"
                                      f"‚úÖ ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑŸáÿß ŸÑŸÄ 0 ŸÖÿ≥ÿ™ÿÆÿØŸÖ\n"
                                      f"‚ùå ŸÅÿ¥ŸÑ ÿ•ÿ±ÿ≥ÿßŸÑŸáÿß ŸÑŸÄ 0 ŸÖÿ≥ÿ™ÿÆÿØŸÖ")
        
        for index, user_id in enumerate(user_ids):
            try:
                # ÿ™ÿÆÿ∑Ÿä ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿ∫Ÿäÿ± ÿßŸÑÿµÿßŸÑÿ≠ŸäŸÜ
                if not user_id or user_id == 0:
                    continue
                    
                bot.send_message(user_id, f"üì¢ ÿ•ÿ¥ÿπÿßÿ± ŸÖŸÜ ÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿ®Ÿàÿ™:\n\n{broadcast_text}")
                success_count += 1
                
                # ÿ™ÿ≠ÿØŸäÿ´ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ™ŸÇÿØŸÖ ŸÉŸÑ 10 ŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ
                if index % 10 == 0:
                    try:
                        bot.edit_message_text(
                            f"‚è≥ ÿ¨ÿßÿ±Ÿä ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÑŸÄ {total_users} ŸÖÿ≥ÿ™ÿÆÿØŸÖ...\n\n"
                            f"‚úÖ ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑŸáÿß ŸÑŸÄ {success_count} ŸÖÿ≥ÿ™ÿÆÿØŸÖ\n"
                            f"‚ùå ŸÅÿ¥ŸÑ ÿ•ÿ±ÿ≥ÿßŸÑŸáÿß ŸÑŸÄ {fail_count} ŸÖÿ≥ÿ™ÿÆÿØŸÖ",
                            message.chat.id,
                            progress_msg.message_id
                        )
                    except:
                        pass
                        
            except Exception as e:
                fail_count += 1
                logger.error(f"ŸÅÿ¥ŸÑ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ {user_id}: {str(e)}")
            
            time.sleep(0.2)  # ÿ™ŸÇŸÑŸäŸÑ ÿßŸÑÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ API
        
        # ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ™ŸÇÿ±Ÿäÿ± ÿßŸÑŸÜŸáÿßÿ¶Ÿä
        report_text = f"""
üìä *ÿ™ŸÇÿ±Ÿäÿ± ÿßŸÑÿ®ÿ´ ÿßŸÑÿ¨ŸÖÿßÿπŸä:*

‚Ä¢ üë• ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑŸÖÿ≥ÿ™ŸáÿØŸÅŸäŸÜ: {total_users}
‚Ä¢ ‚úÖ ÿ™ŸÖ ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑ ÿ®ŸÜÿ¨ÿßÿ≠: {success_count}
‚Ä¢ ‚ùå ŸÅÿ¥ŸÑ ŸÅŸä ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑ: {fail_count}
‚Ä¢ üìà ŸÜÿ≥ÿ®ÿ© ÿßŸÑŸÜÿ¨ÿßÿ≠: {(success_count/total_users*100):.1f}%
        """
        
        bot.send_message(message.chat.id, report_text, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ®ÿ´ ÿßŸÑÿ¨ŸÖÿßÿπŸä: {str(e)}")
        handle_bot_error(message.chat.id, str(e))

@global_error_handler
def handle_callback_query(call):
    try:
        if call.data.startswith("setting_"):
            setting_type = call.data.split("_")[1]
            setting_names = {
                "minute": "rate_limit_minute",
                "hour": "rate_limit_hour",
                "day": "rate_limit_day",
                "cleanup": "auto_cleanup_days"
            }
            
            if setting_type in setting_names:
                current_value = redemption_logger.get_setting(setting_names[setting_type])
                msg = bot.send_message(call.message.chat.id, f"ÿ£ÿØÿÆŸÑ ÿßŸÑŸÇŸäŸÖÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ© ŸÑŸÑÿ•ÿπÿØÿßÿØ ({setting_type}):\nÿßŸÑŸÇŸäŸÖÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©: {current_value}")
                bot.register_next_step_handler(msg, process_setting_change, setting_names[setting_type])
            
        elif call.data.startswith("export_"):
            if call.data == "export_7":
                days = 7
            elif call.data == "export_30":
                days = 30
            elif call.data == "export_90":
                days = 90
            else:
                days = 3650
            
            csv_file = redemption_logger.export_to_csv(days=days)
            
            with open(csv_file, 'rb') as f:
                bot.send_document(call.message.chat.id, f, caption=f"üìä ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿßÿ≥ÿ™ÿ±ÿØÿßÿØÿßÿ™ ŸÑÿ¢ÿÆÿ± {days} ŸäŸàŸÖ")
            
            os.unlink(csv_file)
            
        elif call.data == "cleanup_now":
            redemption_logger.cleanup_old_data()
            bot.send_message(call.message.chat.id, "‚úÖ ÿ™ŸÖ ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÇÿØŸäŸÖÿ© ÿ®ŸÜÿ¨ÿßÿ≠")
            
        elif call.data == "cleanup_24h_codes":
            db_deleted, memory_deleted = cache_system.cleanup_24h_codes()
            
            bot.send_message(
                call.message.chat.id,
                f"‚úÖ ÿ™ŸÖ ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿ£ŸÉŸàÿßÿØ ÿßŸÑŸÖÿ§ŸÇÿ™ÿ© ŸÑÿ¢ÿÆÿ± 24 ÿ≥ÿßÿπÿ©\n\n"
                f"‚Ä¢ üóÉÔ∏è ÿßŸÑÿ£ŸÉŸàÿßÿØ ÿßŸÑŸÖÿ≠ÿ∞ŸàŸÅÿ© ŸÖŸÜ ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™: {db_deleted}\n"
                f"‚Ä¢ üíæ ÿßŸÑÿ£ŸÉŸàÿßÿØ ÿßŸÑŸÖÿ≠ÿ∞ŸàŸÅÿ© ŸÖŸÜ ÿßŸÑÿ∞ÿßŸÉÿ±ÿ©: {memory_deleted}\n"
                f"‚Ä¢ üìä ŸÖŸÑÿßÿ≠ÿ∏ÿ©: ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿØÿßÿ¶ŸÖÿ© ŸÑŸÖ Ÿäÿ™ŸÖ ÿ≠ÿ∞ŸÅŸáÿß",
                parse_mode='Markdown'
            )
            
        elif call.data == "admin_back":
            bot.send_message(call.message.chat.id, "ÿßŸÑÿπŸàÿØÿ© ÿ•ŸÑŸâ ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ•ÿØÿßÿ±Ÿäÿ©", reply_markup=create_admin_keyboard())
        
        bot.answer_callback_query(call.id)
        
    except Exception as e:
        logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ©: {str(e)}")
        handle_bot_error(call.message.chat.id, str(e))

@global_error_handler
def process_setting_change(message, setting_key):
    try:
        new_value = message.text.strip()
        
        if not new_value.isdigit():
            bot.send_message(message.chat.id, "‚ùå Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ŸÉŸàŸÜ ÿßŸÑŸÇŸäŸÖÿ© ÿ±ŸÇŸÖŸäÿ©")
            return
        
        redemption_logger.set_setting(setting_key, new_value)
        bot.send_message(message.chat.id, f"‚úÖ ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ•ÿπÿØÿßÿØ ÿ®ŸÜÿ¨ÿßÿ≠\n{setting_key}: {new_value}", reply_markup=create_admin_keyboard())
        
    except Exception as e:
        logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑÿ•ÿπÿØÿßÿØ: {str(e)}")
        handle_bot_error(message.chat.id, str(e))

@global_error_handler
def handle_all_messages(message):
    if hasattr(message, 'text') and message.text == "üë®‚Äçüíª ŸÑŸàÿ≠ÿ© ÿßŸÑÿ™ÿ≠ŸÉŸÖ" and message.from_user.id != ADMIN_USER_ID:
        bot.send_message(message.chat.id, "‚õî ŸÑŸäÿ≥ ŸÑÿØŸäŸÉ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑŸàÿµŸàŸÑ ÿ•ŸÑŸâ Ÿáÿ∞Ÿá ÿßŸÑŸÖŸäÿ≤ÿ©",
                        reply_markup=create_main_keyboard(message.from_user.id))
        return
    
    redemption_logger.log_request(message.from_user.id, 'message')
    
    allowed, error_msg = rate_limit_check(message.from_user.id)
    if not allowed:
        bot.send_message(message.chat.id, error_msg)
        return
    
    text = message.text.strip()
    
    if text in ["üéÅ ÿßÿ≥ÿ™ÿ±ÿØÿßÿØ ŸÉŸàÿØ", "üìä ÿßÿ≥ÿ™ÿ±ÿØÿßÿØÿßÿ™Ÿä", "‚ÑπÔ∏è ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ©", "üë®‚Äçüíª ŸÑŸàÿ≠ÿ© ÿßŸÑÿ™ÿ≠ŸÉŸÖ", "üìà ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™", "‚öôÔ∏è ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™", "üì§ ÿ™ÿµÿØŸäÿ± ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™", "üßπ ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™", "üì¢ ÿ®ÿ´ ÿ¨ŸÖÿßÿπŸä", "üîô ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©"]:
        return
    
    valid_codes, skipped_codes = extract_and_filter_codes(text)
    
    if not send_initial_filter_report(message, valid_codes, skipped_codes):
        return
    
    if valid_codes:
        if len(valid_codes) == 1:
            add_to_task_queue({
                'type': 'single_code',
                'message': message,
                'code': valid_codes[0]
            })
            
            bot.send_message(message.chat.id, 
                            f"‚úÖ ÿ™ŸÖÿ™ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸÉŸàÿØ ÿ•ŸÑŸâ ÿ∑ÿßÿ®Ÿàÿ± ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©\n"
                            f"üìã ÿßŸÑŸÉŸàÿØ: `{valid_codes[0]}`",
                            parse_mode='Markdown')
        else:
            add_to_task_queue({
                'type': 'multiple_codes',
                'message': message,
                'codes': valid_codes
            })
            
            bot.send_message(message.chat.id, 
                            f"‚úÖ ÿ™ŸÖÿ™ ÿ•ÿ∂ÿßŸÅÿ© {len(valid_codes)} ŸÉŸàÿØ ÿ•ŸÑŸâ ÿ∑ÿßÿ®Ÿàÿ± ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©\n"
                            f"‚è≥ ÿ¨ÿßÿ±Ÿä ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©...",
                            parse_mode='Markdown')

if hasattr(bot, 'message_handler'):
    bot.message_handler(commands=['start', 'help'])(send_welcome)
    bot.message_handler(func=lambda message: hasattr(message, 'text') and message.text == "‚ÑπÔ∏è ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ©")(help_menu)
    bot.message_handler(func=lambda message: hasattr(message, 'text') and message.text == "üìä ÿßÿ≥ÿ™ÿ±ÿØÿßÿØÿßÿ™Ÿä")(show_redemptions)
    bot.message_handler(func=lambda message: hasattr(message, 'text') and message.text == "üéÅ ÿßÿ≥ÿ™ÿ±ÿØÿßÿØ ŸÉŸàÿØ")(ask_for_code)
    bot.message_handler(func=lambda message: hasattr(message, 'text') and message.text == "üë®‚Äçüíª ŸÑŸàÿ≠ÿ© ÿßŸÑÿ™ÿ≠ŸÉŸÖ" and message.from_user.id == ADMIN_USER_ID)(admin_panel)
    bot.message_handler(func=lambda message: hasattr(message, 'text') and message.text == "üîô ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©" and message.from_user.id == ADMIN_USER_ID)(admin_back_to_main)
    bot.message_handler(func=lambda message: hasattr(message, 'text') and message.text == "üìà ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™" and message.from_user.id == ADMIN_USER_ID)(admin_statistics)
    bot.message_handler(func=lambda message: hasattr(message, 'text') and message.text == "‚öôÔ∏è ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™" and message.from_user.id == ADMIN_USER_ID)(admin_settings)
    bot.message_handler(func=lambda message: hasattr(message, 'text') and message.text == "üì§ ÿ™ÿµÿØŸäÿ± ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™" and message.from_user.id == ADMIN_USER_ID)(admin_export_data)
    bot.message_handler(func=lambda message: hasattr(message, 'text') and message.text == "üßπ ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™" and message.from_user.id == ADMIN_USER_ID)(admin_cleanup_data)
    bot.message_handler(func=lambda message: hasattr(message, 'text') and message.text == "üì¢ ÿ®ÿ´ ÿ¨ŸÖÿßÿπŸä" and message.from_user.id == ADMIN_USER_ID)(admin_broadcast)
    bot.message_handler(func=lambda message: True)(handle_all_messages)

    if hasattr(bot, 'callback_query_handler'):
        bot.callback_query_handler(func=lambda call: True)(handle_callback_query)

def auto_cleanup():
    try:
        redemption_logger.cleanup_old_data()
        cache_system.clear_expired()
        logger.info("‚úÖ ÿ™ŸÖ ÿßŸÑÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä ÿ®ŸÜÿ¨ÿßÿ≠")
    except Exception as e:
        logger.error(f"‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä: {str(e)}")
    finally:
        threading.Timer(24 * 60 * 60, auto_cleanup).start()

if __name__ == "__main__":
    logger.info("üöÄ ÿ®ÿØÿ° ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ®Ÿàÿ™...")
    
    threading.Timer(60, auto_cleanup).start()
    
    if not BOT_TOKEN or BOT_TOKEN == 'ÿ™ŸàŸÉŸÜ_ÿßŸÑÿ®Ÿàÿ™_ÿßŸÑÿÆÿßÿµ_ÿ®ŸÉ':
        print("üîç ŸäÿπŸÖŸÑ ÿßŸÑÿ®Ÿàÿ™ ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ± ÿßŸÑŸÖÿ≠ŸÑŸä")
        print("üí° ŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ®Ÿàÿ™ ÿßŸÑÿ≠ŸÇŸäŸÇŸäÿå ÿ£ÿ∂ŸÅ BOT_TOKEN ŸÅŸä ŸÖŸÑŸÅ .env")
    else:
        print("ü§ñ ÿ®ÿØÿ° ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ®Ÿàÿ™ ÿßŸÑÿ≠ŸÇŸäŸÇŸä")
        while True:
            try:
                bot.polling(none_stop=True, timeout=120)
            except Exception as e:
                logger.error(f"‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ®Ÿàÿ™: {e}")
                
                if ADMIN_USER_ID != 0:
                    try:
                        bot.send_message(ADMIN_USER_ID, 
                                       f"üî¥ ÿßŸÑÿ®Ÿàÿ™ ÿ™ŸàŸÇŸÅ ÿ®ÿ≥ÿ®ÿ® ÿÆÿ∑ÿ£:\n{str(e)}",
                                       parse_mode='Markdown')
                    except:
                        pass
                
                logger.info("üîÑ ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ÿ®ÿπÿØ 15 ÿ´ÿßŸÜŸäÿ©...")
                time.sleep(15)